<!doctype html>
<html lang="en">
<head>
  <title>R</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>
<style>
 body { margin: 0; }
 #page { overflow: hidden; }
</style>
<body>
<div id="page"></div>

<script src="http://threejs.org/build/three.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/THREEx.WindowResize.js"></script>
<script>

var outlinePrecision = 6;
var outlineWidth = 9;
var shapeWidth = 160;

var cylinderMesh = function(a, b, radius, material) {
  var direction = b.clone().sub(a);

  var geometry = new THREE.CylinderGeometry(radius, radius, direction.length(), outlinePrecision, 4);
  var edge = new THREE.Mesh(geometry, material);
  edge.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction.clone().normalize());
  edge.position.copy(a.clone().add(direction.clone().multiplyScalar(0.5)));

  return edge;
};

var outlinedSheet = function(x, y, outlineWidth, material, outlineMaterial, uncapped) {
  var group = new THREE.Object3D();
  var geometry = new THREE.BoxGeometry(x, y, outlineWidth / 2);
  var cube = new THREE.Mesh(geometry, material);
  group.add(cube);

  var corners = [[0, 0], [1, 0], [1, 1], [0, 1]];
  var cornerVectors = corners.map(function(position) {
    var sphereGeometry = new THREE.SphereGeometry(outlineWidth / 2, outlinePrecision, outlinePrecision);
    var corner = new THREE.Mesh(sphereGeometry, outlineMaterial);
    corner.position.set(position[0] * x - x / 2, position[1] * y - y / 2, 0);
    group.add(corner);
    return corner.position;
  });

  var previous = cornerVectors[cornerVectors.length - 1];
  cornerVectors.map(function(current, i) {
    if (uncapped !== i) {
      group.add(cylinderMesh(previous, current, outlineWidth / 2, outlineMaterial));
    }
    previous = current;
  });

  return group;
};

var outlinedCurve = function(segments, angle, radius, width, outlineWidth, materials, outlineMaterial) {
  var group = new THREE.Object3D();

  var sphereGeometry = new THREE.SphereGeometry(outlineWidth / 2, outlinePrecision, outlinePrecision);
  var axis = new THREE.Vector3(0, 1, 0);
  var widthVector = new THREE.Vector3(0, width, 0);

  var innerRadius = new THREE.Vector3(radius - outlineWidth / 2, 0, 0);
  var midleRadius = new THREE.Vector3(radius - outlineWidth / 2 / 2, 0, 0);
  var outerRadius = new THREE.Vector3(radius, 0, 0);

  var section, segmentAngle, lastSegmentAngle, lastPosition;
  for (var i = 0; i <= segments; i++) {
    segmentAngle = angle * i / segments;
    if (lastSegmentAngle !== undefined) {
      section = new THREE.BoxGeometry(1, 1, 1);
      section.vertices[0] = outerRadius.clone().applyAxisAngle(axis, segmentAngle).add(widthVector);
      section.vertices[1] = outerRadius.clone().applyAxisAngle(axis, segmentAngle);
      section.vertices[2] = outerRadius.clone().applyAxisAngle(axis, lastSegmentAngle).add(widthVector);
      section.vertices[3] = outerRadius.clone().applyAxisAngle(axis, lastSegmentAngle);
      section.vertices[4] = innerRadius.clone().applyAxisAngle(axis, segmentAngle);
      section.vertices[5] = innerRadius.clone().applyAxisAngle(axis, segmentAngle).add(widthVector);
      section.vertices[6] = innerRadius.clone().applyAxisAngle(axis, lastSegmentAngle);
      section.vertices[7] = innerRadius.clone().applyAxisAngle(axis, lastSegmentAngle).add(widthVector);

      section.faces.map(function(face) {
        face.materialIndex = 0;
      });
      section.faces[2].materialIndex = 1;
      section.faces[3].materialIndex = 1;
      section.faces[4].materialIndex = 1;
      section.faces[5].materialIndex = 1;

      faceMaterial = new THREE.MeshFaceMaterial();
      faceMaterial.materials = [lightBlue, yellow];

      group.add(new THREE.Mesh(section, faceMaterial));
    }

    var sphere1 = new THREE.Mesh(sphereGeometry, outlineMaterial);
    sphere1.position.copy(midleRadius.clone().applyAxisAngle(axis, segmentAngle));
    group.add(sphere1);

    var sphere2 = new THREE.Mesh(sphereGeometry, outlineMaterial);
    sphere2.position.copy(sphere1.position).add(widthVector)
    group.add(sphere2);

    if (lastPosition) {
      group.add(cylinderMesh(lastPosition, sphere1.position, outlineWidth / 2, outlineMaterial));
      group.add(cylinderMesh(
        lastPosition.clone().add(widthVector),
        sphere2.position,
        outlineWidth / 2,
        outlineMaterial
      ));
    }

    lastPosition = sphere1.position;
    lastSegmentAngle = segmentAngle;
  }

  return group;
}

var scene = new THREE.Scene();

// var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 20000);
// scene.add(camera);
// camera.position.set(700, 300, -600);
// camera.lookAt(scene.position);

var width = window.innerWidth;
var height = window.innerHeight;
var camera = new THREE.OrthographicCamera(width / - 2, width / 2, height / 2, height / - 2, 0.1, 100000);
camera.position.set(800, 200, -600);
camera.lookAt(scene.position);

var renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);

var container = document.getElementById('page');
container.appendChild(renderer.domElement);

// THREEx.WindowResize(renderer, camera);

var controls = new THREE.OrbitControls(camera, renderer.domElement);

var light = new THREE.PointLight(0xffffff);
light.position.set(0, 150, 100);
scene.add(light);

var lightBlue = new THREE.MeshBasicMaterial({ color: 0x7be0fb });
var yellow = new THREE.MeshBasicMaterial({ color: 0xfce057 });
var darkBlue = new THREE.MeshBasicMaterial({ color: 0x3665c7 });

var outlineMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });

var shape = new THREE.Object3D();

var head = outlinedSheet(shapeWidth, 118, outlineWidth, yellow, outlineMaterial);
head.position.set(0, 148, -59);
head.rotation.x = Math.PI / 2;
shape.add(head);

var middle = outlinedSheet(shapeWidth, 118, outlineWidth, yellow, outlineMaterial, 1);
middle.position.set(0, -28, -63);
middle.rotation.x = Math.PI / 2;
shape.add(middle);

var leg = outlinedSheet(shapeWidth, 150, outlineWidth, lightBlue, outlineMaterial);
leg.position.set(0, -92, -168);
leg.rotation.x = Math.PI * 1 / 5;
shape.add(leg);

var back = outlinedSheet(shapeWidth, 298, outlineWidth, darkBlue, outlineMaterial);
back.position.set(0, -1, 0);
shape.add(back);

var curve = outlinedCurve(16, Math.PI, 90, shapeWidth, outlineWidth, [lightBlue, yellow], outlineMaterial);
curve.rotation.z = Math.PI / 2;
curve.position.x = shapeWidth / 2;
curve.position.y = 60;
curve.position.z = -120;
shape.add(curve);

shape.position.z = 100;
scene.add(shape);

var animate = function() {
  renderer.render(scene, camera);
  controls.update();
  requestAnimationFrame(animate);
}

animate();

</script>

</body>
</html>
